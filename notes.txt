first parts:

1.petition page with first and last name with submit button and canvas

for the signature:
when the mouse goes down record the position. when the mouse moves draw a line to new x and y and remove
the old coordinates

when user clicks submit, first, last name and image data are submitted to the server.

to get the signature image data:

var c = document.querySelector('canvas');

c.toDataURL(); - produces a base64 encoded data url

<form method='POST'>
    <input type= 'text'>
    <input type= 'text'>
    <input type = 'hidden'> change the value of the input with image data from the signature
    <button><button>
    </form>
    <canvas></canvas>

2. create a db for the project with a table named signatures. when a user posts a sig, insert data into this table

CREATE TABLE signatures(
id SERIAL PRIMARY KEY,
first VARCHAR(300) NOT NULL,
last VARCHAR(300) NOT NULL,
signature text NOT NULL,
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)

//





when the data is successfully redirected with the post req.

3. Thank you page for after signing the petition
make sure if the user inserted a signature to the db. place a cookie to check if already signed

4- page of everyone who ever signed the petition, no signature


create index.js, body-parser, cookie-parser, express, express handlebars, express static, create a database,
views, get and post route for the petition page,
 1 get for thankyou, 1 get for all signatures
browser.js for the canvas

//SQL SHIT:

// var spicedPg = require('spiced-pg');
//
// var db = spicedPg('postgres:dbuser:password@localhost:5432/cities');
//
// db.query('SELECT * FROM cities WHERE id =1').then(function(results){
//     console.log(results.rows);
// }).catch(function(err){
//     console.log(err);
// });

//to escape  characters in SQL

// function findCity(name, id){
//     db.query(
//         'SELECT * FROM cities WHERE city = $1 AND id = $2',
//         [name, id]
//     ).then(function(result) {
//         console.log(result.rows);
//     }).catch(function(err){
//         console.log(err);
//     });
// }
// ///_______________________________________________

don't store your signature in the session because it's too long

query to our database using our signatureId to get all information from the databas

______
after the create hash function, call an insert to table function

when running the checkpass function, to get the 'hashedpasswordfromdb', run a select whatever from database
where email = ...

checkpassword will also resolve a boolean value. if(doesMatch) - then redirect to ....

//INNER JOIN
//LEFT RIGHT OR FULL JOINS ARE OUTER JOINS

when user logs in:
select users.first, users.last, users.pass, users.id, signatures.id as signatureId
FROM USERS
left join signatures
on users.id = signatures.user_id


app.get('/signers/:city', function(req, res){

})

in postgres lower function to make case insensitive:
SELECT ID
FROM groups
WHERE LOWER(name) = LOWER('Administrator')

//

On edit profile page we need a select query with a join clause
then populate with res.render

app.get('/edit-profile', (req, res)=>{
const q='select all the stuff'
const params =[]

exports.getStuff = function ()
db.query(q, params)
    .then(()=>{
        console.log(results.rows[0])
    })
})


check if the user has a row in user_profiles. if there isn't, do an insert. if there is, do an update.
OR- add insert to profile page after register, even if users didn't add any info(to add a row for them in user_profiles).

if users update password, run through the hash thing and update it.

use a delete query to delete the row with the signature in it, if the user wants to unsign.
(DELETE FROM table WHERE user_id = thatId)

UPDATE table

SET column first = newnamevalue
SET column city = newcityvalue

WHERE condition

on psql run \dt to see a list of all tables
        run \du to see users on our machine


////////
&lt;script src=&quot; - place outside user input to disallow malicious attacks trying to
inject scripts in your site
handlebars, react and angular do that automatically

{{{body}}} (triple curly) in handlebars tells the computer not to escape it

To prevent clickjacking using express:

app.use(function(req,res, next){
res.setHeader('x-frame-options', 'deny');
next();
})

helmetjs -  library for express with security modules
to prevent???- by helmetjs
app.disable('x-powered-by');


never send the error object back, cause it may contain vulnerabilities a hacker can exploit.
Send an error message that you created to the user.

after app.use crsurf, add 'csrfToken' to the res.render of the get request with the secret pass
 you choose

add another input type hidden and name it '_csrf' and put the token in it as
a value='{{csrfToken}}'


to delete button, make it a form with post method and a hidden input type
//
npm start is an alternate way to run server

heroku commands
heroku run bash - use cli commands on heroku like ls
heroku logs - check all logs

///Check tobi's app.use csrftoken use

ttl = time to live (before invalidating stale cache)

//run redis with

redis -server --daemonize yes
then node cache.js//name of the file

const redis = require('redis');

var client = redis.createClient({
    host:'localhost',
    port:6379
});

client.on('error', function(err){
console.log(err)
})

client.set('key', 'value', function(e, data){
    console.log(err,data)// null 'ok'
})

then:
client.get('key', function(e, data){
    console.log(err,data)// returns null 'value'
})

client.setex('key', 20, 'value', function(e, data){
    console.log(err,data)// set a key and give it a ttl of 20 seconds
})

exports.get = function(key){
    return new Promise (function(resolve, reject){
        client.get(key, function(err, data){
            if (err){
                reject(err);
            } else {
                resolve(data); //use JSON.parse(data) for instance, if every data coming in is a json
            }
        })
    })
}

exports.setex = function(key){
    return new Promise (function(resolve, reject){
        client.setex(key, expiry, JSON.stringify(val), function(err, data){
            if (err){
                reject(err);
            } else {
                resolve(JSON.parse(data));
            }
        })
    })
}

writing redish -cli in the terminal allows you to run all above commands in the terminal

keys * //shows all values

set key value //setting a key value pair

setex name 10 leonardo// give the key value 10 seconds to exist
get name 'leonardo'// will be gona after 10 seconds
del key //to invalidate smtg in the cache

a cache 'miss' will result in nil and it means it's not in there

////
press t in github to search through files
EMPTY ARRAYS AND EMPTY OBJECTS ARE TRUTHY, SO TO CHECK FOR THEIR EXISTENCE,
LOOK FOR LENGTH=0, DON'T USE IF(!)
Mvc = model view controller



HOW DO I UPLOAD THE NEW BRANCH TO HEROKU
ERROR WHEN USER USING SAME DETAILS TO REGISTER
